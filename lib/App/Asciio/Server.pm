
package App::Asciio::Server ;

use strict ; use warnings ;

use Data::TreeDumper ;

use Socket ;
use Gtk3::Helper;

use HTTP::Daemon ;
use HTTP::Request::Params ;
use HTTP::Status ;
use HTTP::Tiny;

use App::Asciio::Scripting ;
use JSON ;

# ---------------------------------------------------------------------------------------------- 

my $REQUEST_FLOW = <<'EOT' ;
| Flow              | Direction          | Protocol      | Data Contents             | Role of Request ID                                    |
| -                 | -                  | -             | -                         | -                                                     |
| External Request  | Browser -> Server  | HTTP GET      | Original Request Data     | Generated by Server; used to map connection $c        |
| Request IPC       | Server  -> Asciio  | Socket Pair   |                           | Sent to Asciio to identify which request to answer    |
| Response IPC      | Asciio  -> Server  | Socket Pair   |                           | Sent back to Server to add to external respons        |
| External Response | Server  -> Browser | HTTP          | Final HTTP Response       | Used by Server to fulfill the initial browser request |  

EOT

# ---------------------------------------------------------------------------------------------- 

{
my $response_connection ;

sub RESPONSE_REGISTER { ($response_connection) = @_ ; }

sub RESPONSE_RAW
{
my ($response) = @_ ;

my $r = HTTP::Response->new(RC_ACCEPTED) ;
$r->content($response) ;

$response_connection->send_response($r) ;
}

sub RESPONSE
{
my ($response) = @_ ;

my $r = HTTP::Response->new(RC_ACCEPTED) ;
$r->content( join '&', map { $_ . '=' . ($response->{$_} // 'undef') } keys %$response ) ;

$response_connection->send_response($r) ;
}

}

# ---------------------------------------------------------------------------------------------- 

sub start_web_server
{
my ($self, $port, $callback) = @_ ;

my ($to_child, $to_parent) ;
socketpair($to_child, $to_parent, AF_UNIX, SOCK_STREAM, PF_UNSPEC) or die "socketpair: $!" ;

my $pid = fork() ;
if ($pid)
	{
	close($to_parent) ;
	
	$to_child->autoflush(1);
	
	my $tag ;
	$tag = Gtk3::Helper->add_watch
		(
		$to_child->fileno, 
		'in', 
		sub { web_server_callback($to_child, [$self, $tag, $callback, $port] ) }
		) ;
	
	$self->{GTK3_TAG} = {TAG => $tag, PID => $pid, PORT => $port} ;
	$self->{ON_EXIT} = 
		sub
		{
		Gtk3::Helper->remove_watch($self->{GTK3_TAG}{TAG}) or die "GTK3::Helper: couldn't remove watcher" ;
		kill 15, $self->{GTK3_TAG}{PID} ;
		} ;
	
	return($to_child, $pid) ;
	}
else
	{
	unless (defined $pid)
		{
		close($to_child) ;
		close($to_parent) ;
		return ;
		}
		
	close($to_child) ;
	
	$to_parent->autoflush(1) ;
	
	my $daemon = HTTP::Daemon->new
		(
		ReusePort => 1, 
		LocalAddr => 'localhost', 
		LocalPort => $port
		) or die "Server: Error: can't start server\n" ;
	print STDERR "Asciio: running HTTP server on port $port\n" ;
	
	$SIG{INT} = sub {
			print STDERR "Asciio: Web Server received SIGINT\n" ;
			undef $daemon ;
			} ;
	
	$SIG{TERM} = sub
			{
			print STDERR "Asciio: Web Server received SIGTERM\n" ;
			undef $daemon ;
			} ;
	
	my $stop    = 0 ;
	my $counter = 0 ;
	
	while (defined $daemon and my $c = $daemon->accept)
		{
		RESPONSE_REGISTER $c ;
		my $keep_connection_open = 0 ;
		$counter++ ;
		
		while (my $rq = $c->get_request)
			{
			my $path = $rq->uri->path ;
			
			print STDERR "Asciio: Http: " . $rq->method . ' ' . $daemon->url . "$path, count: $counter - $$\n" ;
			
			if ($rq->method eq 'GET')
				{
				my $parser = HTTP::Request::Params->new({req => $rq}) ;
				my $parameters = $parser->params() ;
				
				my $request_data = { PATH => $path, PARAMETERS => $parameters } ;
				
				if ('/' eq $path)
					{
					RESPONSE { TEXT => "Asciio web interface\ncounter: $counter" };
					$c->force_last_request ;
					}
				elsif ('/get_current_tab_id' eq $path)
					{
					my $request_json = JSON->new->allow_nonref->canonical(1)->pretty->encode($request_data) ;
					
					print $to_parent pack 'L', length($request_json) ;
					print $to_parent $request_json ;
					
					my $answer = <$to_parent> ;
					
					RESPONSE { tab_id  => $answer } ;
					
					$c->force_last_request ;
					}
				else
					{
					RESPONSE { TEXT => "GET requests not supported for main app communication on path $path." } ;
					$c->force_last_request ;
					}
				}
			elsif ($rq->method eq 'POST')
				{
				local @ARGV = () ; # otherwise it ends up in the parsed parameters
				
				my $parser = HTTP::Request::Params->new({req => $rq}) ;
				my $parameters = $parser->params() ;
				
				# '/' eq $path && print STDERR "Asciio:: Web server: POST\n" . DumpTree($parameters) ; 
				
				my $request_json = JSON->new->allow_nonref->canonical(1)->pretty->encode({ PATH => $path, PARAMETERS => $parameters}) ;
				
				print $to_parent pack 'L', length($request_json) ; 
				print $to_parent $request_json ; 
				print "ready to send response\n" ;
				
				$c->send_status_line ;
				$c->send_crlf ;
				$c->force_last_request ;
				}
			elsif ($rq->method eq 'PUT')
				{
				local @ARGV = () ;
				
				my $parser = HTTP::Request::Params->new({req => $rq}) ;
				my $parameters = $parser->params() ;
				
				'/stop' eq $path && $stop++ ;
				
				my $request_data = { PATH => $path, PARAMETERS => $parameters } ;
				
				my $request_json = JSON->new->allow_nonref->canonical(1)->pretty->encode($request_data) ;
				
				print $to_parent pack 'L', length($request_json) ;
				print $to_parent $request_json ;
				
				$c->send_status_line ;
				$c->send_crlf ;
				$c->force_last_request ;
				}
			}
		
		$c->close unless $keep_connection_open ;
		
		print "Waiting for connection\n" ;
		last if $stop ;
		}
	}
}

# ---------------------------------------------------------------------------------------------- 

sub web_server_callback
{
my ($fh, $asciio_tag_callback) = @_ ;

my ($asciio, $tag, $callback, $port) = $asciio_tag_callback->@* ;

my ($size, $buffer) ;
sysread($fh, $size, 4) ;
$size = unpack 'L', $size ;

unless (sysread($fh, $buffer, $size))
	{
	Gtk3::Helper->remove_watch($tag) or die "GTK3::Helper: couldn't remove watcher" ;
	close($fh) ;
	
	delete $asciio->{ON_EXIT} ;
	
	return 1 ;
	}

my $request = JSON->new->decode($buffer) ;

my $path       = $request->{PATH} ;
my $parameters = $request->{PARAMETERS} ;

my $answer ;

if (defined $callback)
	{
	$answer = $callback->($asciio, $request, $path, $parameters, $fh) ;
	}
else
	{
	'/script_file' eq $path && App::Asciio::Scripting::run_external_script($asciio, $parameters->{script} // '') ;
	'/script'      eq $path && App::Asciio::Scripting::run_external_script_text($asciio, $parameters->{script} // '', $parameters->{show_script}) ;
	}


return 1 ;
}

# ---------------------------------------------------------------------------------------------- 

1 ;
